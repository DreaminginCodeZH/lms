# C程序设计专题 小班研讨专题报告

## 元数据

### 项目

图书管理系统

### 组号

22

### 成员

张海 3130000923

欧阳昱博 3130000844

### 报告提交人

张海 18970920012 <3130000923@zju.edu.cn>

### 任课教师

肖少拥

### 递交日期

2014年4月2日

## 功能说明

本系统具有对图书信息进行增加、修改、删除、多条件模糊搜索和显示的功能，图书信息使用二进制文件进行存储。

## 使用说明

### 安装说明

#### 开发环境

* 操作系统：Arch Linux / (Windows 8.1 + MinGW)

* 集成开发环境：Eclipse Kepler with CDT

* 编译器：gcc 4.8

#### 可执行文件生成

* 使用 Eclipse with CDT 导入工程并进行组建。

* 编写`makefile`并手动进行编译链接。

#### 文件说明

* src/

  源代码文件

* doc/

  文档文件

### 操作说明

本系统采用字符菜单界面，进入系统时可以在主界面选择进行搜索、增加、修改、删除图书、退出系统操作，之后可根据界面提示进一步完成操作，操作完成后将再次回到主界面。

若发生数据文件损坏，系统将提示错误并退出。此时用户可以将数据文件`lms.dat`重命名或删除，则下次运行系统时将重新创建空的数据文件。

## 分工说明

在本项目的协作开发中，张海负责图书信息数据结构及相关算法的实现，并提供了部分调用范例，欧阳昱博负责用户交互模块的实现；二人共同进行了报告文档的撰写。

## 程序说明

### 程序架构

在写作本系统时，我们意识到许多代码都具有通用意义，因此可以以模块化的形式，将各个功能拆分并一般化，组成一个通用的库，以便代码复用。

在这个程序中，代码被主要拆分为三个模块：

1. 通用库

   通用库中主要包含了：

   * `bool`，`string`类型定义与相关常用函数；

   * 各类型序列化及逆序列化函数；

   * 通用的链表、动态数组实现；

   * 控制台函数，包括打印，读取，读取选项，清理，暂停等。

2. 图书信息数据结构

   * `Book`

     图书的数据结构，包含新建、删除、序列化、逆序列化、引用计数、打印等方法。

   * `BookList`

     图书列表的数据结构，“继承”于`LinkedList`类，包含新建、删除、序列化、逆序列化、添加、插入、删除、交换、排序、查找等方法。

   * `BookFilters`

     图书查询过滤器的集合，包括对`Book`各个成员进行模糊搜索、对所有成员进行模糊搜索以及使用多个以上过滤器进行过滤的复合过滤器。

3. 用户交互部分

   主要由`Lms`中的函数组成，调用`Console`中的函数实现了程序的各个功能对于用户的接口，对外提供各个功能的函数以及主循环的接口。

   在`main`中简单地调用了`Lms_loop()`，启动主循环，之后返回状态`0`。

### 数据结构

1. 链表

   本系统中`LinkedList`类提供了双向链表的实现，在基础的增减操作外同时提供了冒泡排序、顺序查找功能，并在`BookList`中被使用。

2. 动态数组

   本系统中`ArrayList`类提供了动态数组的实现，由于需求与时间均较少，仅仅提供了在尾部增加的功能，并在`BookFilters_compound`中被使用。

3. 图书类型

   本系统中`Book`类提供了对图书数据的表示，实现了要求中的字段，同时使用了字符串指针而非数组从而理论上没有引入对输入长度的限制。

### 函数说明

本系统对部分代码片段进行了注释，并采用`Doxygen`生成文档，现提供以下的一部分链接：

* [所有文件](doxygen/html/files.html)

* [`Book`](doxygen/html/Book_8c.html)

* [`BookList`](doxygen/html/BookList_8c.html)

## 系统设计

### 使用工具

1. `git`与`GitHub`

   由于本系统的建立采用了多人合作的方式，因此代码的共享与合并是需要解决的问题。本次实践中，我们采用了`git`这个分布式版本控制系统，并将公用版本库托管在`GitHub`上，从而实现了数条指令即可进行开发的同步与协调。

   在此次数周的开发实践中，我们共进行了 30 余次提交（`Commit`），并创建了两个分支（`Branch`），同时进行过代码回滚的操作，对`git`的特性有了较多的了解。

2. `Eclipse with CDT`

   在比较了多个已知的跨平台`IDE`后，我们决定使用`Eclipse with CDT`进行开发，因为它对代码高亮、代码补全等等特性的支持较为完善，可以提供舒适的开发环境，避免编程问题以外的干扰。

3. `Doxygen`

   为了便于开发协作以及报告撰写，我们采用了`Javadoc`风格的文件内注释，即在每个重要函数的实现处添加函数说明，从而让许多注意事项与调用约定可以在编写函数时即记录至文档之中，避免遗漏及便于修改。

   在编写完成后，我们找到了托管在[`GitHub`](https://github.com/doxygen/doxygen)上的开发源代码项目`Doxygen`进行文档的生成。在修改了一些配置文件后，已经可以产生相对令人满意的`HTML`文档输出。

### 编程风格

在这个项目的编写过程中，我们采用了统一的编程风格与命名规则，使程序的代码一致而易读。

在项目

1. `1TBS`（One True Brace Style）变体缩进风格

   `1TBS`缩进风格是`K&R`风格的变体，而本次我们采用的则是`Java`使用的`1TBS`缩进风格变体，其中包括总是使用花括号等可以避免棘手错误的原则。

2. `Java`风格命名规范

   本系统代码中采用的是`Java`风格命名规范，可以大致概括为类名首字母大写，方法及非常量字段首字母小写的驼峰命名法及常量大写并以下划线分隔单词的命名方法。针对`C`语言的特点，我们约定函数的命名方式为`ClassName_methodName`。

### 设计思想

1. 模块化

   本系统代码行数（不计空行）约为 1500 行，所以如何管理编写的代码是值得考虑的问题。编写时我们采用了模块化的思想，将任务拆分为不同的模块，从而分散到不同的文件，减小了代码的偶合度，同时增强了可复用性。

2. DRY（Don't Repeat Yourself）

   在编程过程中，常常会遇到有多个函数拥有重复的代码段，这时如果可以将重复的代码段提取成为一个通用的函数，则可以缩短单个函数的长度，使代码意图更加明确；同时可以将某个功能的实现集中，从而为代码维护带来便捷；此外这种方式也常常可以创造出可复用的函数。

   本系统中使用此思想的范例即是对控制台用户交互函数的提取，从而使例如询问用户多个选项，编辑书目某一信息等操作只需在用户交互的函数中调用同一实现解决，大大增加了代码的可读性与易维护性。

3. 面向对象编程

   在尚未开始设计时，我们原本的计划时使用纯粹的`C`语言风格编写本系统。然而在规划系统的各个模块时，我们希望各个模块能够相对独立，减小耦合度从而便于分工合作，因此有了对`封装`的需求。在这种情况下，我们选择了采用`module_name_mehtod_name`的命名规范来对各个模块的函数进行拆分与归类。

   在实现了各个模块的`封装`之后，我们发现`book_list`的链表结构其实是通用的一个双向链表实现，因此想要将这个实现拆分出来方便日后的代码复用。那么，`book_list`自然就成为了`继承`于`linked_list`的一个派生类，`继承`的概念在`封装`之后被引入了我们的程序，所以我们决定放弃`C`语言本身`面向过程编程`的方式，开始使用`面向对象编程`的思想组织代码，同时开始采用`Java`风格的命名规范。

   确立了面向对象编程的方法后我们顺利编写了大量代码，直到引入`引用计数`的内存管理后链表节点的创建与释放需要在派生的`BookList`类中进行`重写`，以便基类`LinkedList`可以正确地对`Book`对象进行内存管理。因此，我们想到了利用`C`语言中函数指针的特性，建立函数指针列表以实现类的`多态`性（类似于`C++`中的`vftable`）。

   至此，我们基本完成了`面向对象编程`的三大特点在`C`语言中的实践。这三个特性的引入，并非将另一语言的思想生搬硬套地代入，而是从实际需要出发的不断补充，并且优雅地解决了程序开发中的代码组织问题，因此我们认为这次实践拥有一定的价值。

4. 资源获取即初始化（RAII，Resource Acquisition Is Initialization）

   本系统在编写时借助于面向对象编程的方法，同时通过程序员间的约定，实行了`RAII`的策略，即每个对象的创建都由相应的`ClassName_new`执行而非手动分配内存，从而避免了未初始化的资源可能带来的程序错误。

### 实现特点

1. 不限长度字符串的处理

   因为需求中没有关于字符串长度的说明，所以我们假定用户输入的字符串应当可以为任意长度。因此，我们在`Book`结构体中全部使用了字符串指针，并单独实现了序列化与逆序列化方法，以及相应的内存管理机制。

   同时在用户交互部分，我们也实现了读取一行任意长度用户输入的函数，并采用在`Linux`平台下调用`readline`库，在`Windows`下手动实现的方法实现了跨平台的特性。

2. 基于`引用计数`的内存管理

   为了解决字符串可能带来的内存泄漏，我们建立了类的机制，约定使用RAII及析构函数使各个类分别管理各自成员的内存。

   针对用户需要在`BookList`中搜索`Book`对象，同时搜索结果也将为一个`BookList`的需求，我们决定让每本书在程序中拥有唯一的`Book`示例并让容器类维护引用计数，从而使得书目的编辑、删除变得简洁明了，同时有效解决了内存管理的问题。

3. 多过滤器搜索的实现

   考虑到用户需要访问某本书时，可能需要对书目信息的某几个字段或全文进行不同关键字的搜索，因此我们设计了多过滤器的机制，并通过`BookFilter`结构实现了过滤器的闭包。在`BookFilters`中，我们预先定义了所有单个条目的过滤函数与一个全文过滤函数，同时定义了一个复合过滤函数`BookFilters_compound`，它可以接受一个过滤器列表并分别调用各个过滤器来获得最终的结果。

   在用户交互部分，我们询问用户添加多个过滤器后，即将过滤器列表交给复合过滤函数，由`BookList_search`调用复合过滤器实现过滤。

4. 忽略大小写模糊搜索的实现

   为方便用户查找，我们利用`strstr`函数实现了模糊搜索，同时针对字母大小写，我们在`GNU/Linux`下通过使用`glibc`的扩展函数`strcasestr`，在`Windows`下手动实现，做到了忽略大小写的图书搜索，对于用户来说较为便利。

5. 基于搜索的操作方式

   由于图书管理系统中缺少使用者能够记忆的对书籍的唯一标识符，因此为了满足使用者针对某一本或多本图书进行操作的需求，我们将修改、删除功能也建立在搜索功能之上，从而使得用户可以方便地到达需要操作的书籍，同时也让批量操作成为可能。

6. 细心的交互设计

   在用户交互模块中，我们进行了许多细节上的考虑。

   * 在修改图书信息的时候，由于用户常常只是修改某一条信息，因此程序会对每一条信息是否修改进行询问，同时提供立即保存修改结果并返回的`q`（quit）选项。

   * 在用户添加作者或主题列表的时候，如果用户对列表中某一条的输入为空，则自动过渡到下一项信息的输入。

   * 在用户修改作者或主题列表的时候，如果用户连续对列表中两条的输入为空，则自动将之后的条目清除，并过渡到下一项信息的输入，这是出于用户可能需要增加列表项目的考虑。

7. 良好的容错能力

   由于程序对控制台中选项的输入采用了统一的函数，因此在这个函数中我们可以做到对用户输入是否合适的判定，从而避免因非法输入引起的崩溃。

8. 跨平台的实现

   为了实现程序可以在`Linux`和`Windows`下编译运行，我们针对读取用户输入和字符串比对等函数在不同系统下调用现有的库或进行手动实现，通过判断预处理器常量进行条件编译，从而实现了可移植性。

## 尚待改进

1. 进一步`OOP`的实现

   由于时间匆忙，对成员函数指针列表的实现尚有不妥当之处，今后若有机会可以改进。

2. 从文件中读入指令

   目前可以使用管道代替。

3. 将内容导出为文本文件

   目前可以使用重定向标准输出至文件代替。

4. 对实际运用中大量图书的处理

   目前的实现是在程序启动时读入所有书籍信息，在程序退出时写入数据文件。

   对于大量图书的管理，若自己实现根据需求从文件中读取数据并在内存中建立缓冲较为繁琐，因此一般会采用成熟的数据库进行信息存储。

   若一定要自己实现，可以按照常规方法实现一个数据库，而另一个效率较低但可以处理大量数据的简单实现则是直接利用文件系统的功能，将每本书存储为一个文件，只将需要操作的书籍内容读入内存，并可以实现简单地基于`RLU`策略的缓存。
